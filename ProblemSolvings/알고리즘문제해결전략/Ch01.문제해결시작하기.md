# 01. 문제 해결과 프로그래밍 대회

### 입문자를 위한 추천 커리큘럼

1. Ch02. 문제 해결 전략
2. Ch03. 코딩과 디버깅
3. Ch04. 알고리즘 시간 복잡도 분석
4. Ch06. 무식하게 풀기
5. Ch07. 분할 정복
6. Ch08. 동적 계획법
7. Ch18. 선형 자료 구조
8. Ch19. 큐, 스텍, 덱
9. Ch21. 트리 구현과 순회
10. Ch22. 이진 검색 트리
11. Ch23. 우선순위 큐와 힙
12. Ch27. 그래프의 표현과 정의
13. Ch28. 그래프의 깊이 우선 탐색
14. Ch29. 그래프의 너비 우선 탐색
15. Ch30. 최단 경로 알고리즘

> 복잡한 알고리즘을 하나 더 아는 것보다 실제 자신이 아는 것을 이용해 문제를 풀 수 있는 능력이 훨씬 더 중요하다. 
> 가장 중요한 주제들을 먼저 공부한 뒤에는 가능한 한 많은 문제를 풀어 보며 경험을 쌓는 것이 좋다.

<br />

---

# 02. 문제 해결 개관

## 문제 해결 과정

<어떻게 문제를 풀 것인가(How to Solve it)>; 문제 해결 연구의 고전

1. 문제를 이해한다
2. 어떻게 풀지 계획을 세운다
3. 계획을 수행해서 문제를 해결한다
4. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

⇒ 프로그래밍 대회에 적용

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

**1. 문제를 읽고 이해하기**

문제를 잘못 읽는 실수

- 모든 참가자들이 공통적으로 하는 실수
- 사소한 제약 조건을 잘못 이해하면 풀 수 없게 되는 문제들이 흔하다

**2. 재정의와 추상화**

재정의

- 문제를 자신의 언어로 풀어 쓰는 것

추상화

- 복잡한 개념을 수학적/전산학적 개념으로 옮겨 표현
- 프로그래밍이 나아갈 방향을 결정
- 문제의 본질을 어떤 방식으로 재구성하느냐에 따라 어려운 문제를 쉽게 만들수도, 쉬운 문제를 어렵게 만들수도

**3. 계획 세우기**

문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘와 자료구조 선택

- 문제 해결에서 가장 중요한 단계

**4. 계획 검증하기**

모든 경우에 요구 조건을 정확히 수행하는 지 증명하고,

수행에 걸리는 시간과 메모리가 문제 제한 내에 들어가는지 확인

**5. 계획 수행하기**

계획을 프로그래밍 구현으로

**6. 회고**

장기적으로 가장 큰 영향을 미치는 단계

문제를 한 번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지 못하는 경우가 많다

더 효율적인 알고리즘, 간결한 코드, 더 직관적인 방법을 찾기 위해

가장 좋은 방법은 문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남기는 것

- 간단한 해법
- 접근 방식
- 해법을 찾는 데 결정적이었던 깨달음
- 오답 원인
- 다른 사람의 코드

문제를 풀지 못한 경우

- 일정 시간이 지나도록 고민해도 답을 찾지 못한 경우 다른 사람의 코드/풀이 참조
- 이 경우 반드시 복기; 왜 풀이를 떠올리지 못했는지

## 문제 해결 전략

직관적 아이디어에 체계적으로 접근하기 위한 질문들

1. 비슷한 문제를 풀어본 적이 있던가? 
    - 기존에 접했던 문제가 온전한 경험이 되려면 그 원리를 완전히 이해하고 변형할 수 있어야
2. 단순한 방법에서 시작할 수 있을까? 
    - brute-force → 좀더 효율적인 자료구조/알고리즘, 최적화
3. 내가 문제 푸는 과정을 수식화할 수 있을까? 
    - 영감이 필요한 문제를 만났을 때 손으로 여러 간단한 입력을 해결해 보는 것
4. 문제를 단순화할 수 없을까?
    - 문제의 제약 조건을 없애보거나 변수의 수를 줄이거나 다차원 문제를 1차원으로 줄여 표현해보는 것
5. 그림으로 그려볼 수 있을까?
6. 수식으로 표현할 수 있을까?
7. 문제를 분해할 수 있을까?
    - 다루기 좀더 쉬운 형태로 문제 변형하는 접근
    - 제약 조건을 분해; 한 개의 복잡한 조건 ⇒ 여러 개의 단순한 조건
8. 뒤에서부터 생각해서 문제를 풀 수 있을까?
9. 순서를 강제할 수 있을까?
    - 순서 없는 문제에 순서를 강제
    - 경우의 수 셀 때 유용
10. 특정 형태의 답만을 고려할 수 있을까?
    - 정규화canonicalization

---
