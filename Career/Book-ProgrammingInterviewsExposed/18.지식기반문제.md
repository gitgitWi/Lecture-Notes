# 18. 지식 기반 문제

빈도는 면접/면접관마다 크게 다름
- 아예 안나오거나
- 이것만 나올 수 있음

칠판이나 종이가 없거나, 코딩 능력에 만족한 상태에서 일반적인 CS 지식을 테스트하기 위해

## 준비

지식 기반 문제는 크게 자기소개서에 쓴 내용과 그 전에 물어본 내용, 두 가지를 바탕으로 질문함

- 제출한 이력서, 자소서를 확인해보고, 거기에 나온 어떤 내용에 대해서든 대답할 수 있도록 준비해야
- 제대로 대답하지 못할 것 같다면, 이력서에서 아예 빼버리자
- 면접 도중 답변할 때도, 기술, 기법에 대해 얼마나 잘 알고 있는지 확인하기 위해 더 자세한 설명 요구할 수도 있으므로 주의해야 함
  ```
  ex.
  A. Java 프로그래밍을 시작한 지 ~년 됐습니다
  Q. 처음 써 본 Java 버전이 뭐였나요?
   - 책으로 본 것 말고, 실제 프로그래밍 해 본 버전을 언급해야
  Q. Java 8에서 새로 도입된 기능 중 어떤 게 제일 마음에 들었나요?
  ```
- 프로그래밍 문제를 풀면서 얘기하는 경우에도 마찬가지.
 ```
 ex.
 A. 어떤 알고리즘은 레퍼런스 국소성이 좋지 않아, 효율이 떨어질수 있습니다
 Q. 레퍼런스 국소성이 무엇인가요? 성능에 어떤 영향을 미치나요?
 ```

자신이 사용한 용어 정의를 똑바로 설명할 수 없다면 그 개념을 단순히 외우고만 있을 뿐, 제대로 이해는 하지 못한다는 인상을 줄 수 밖에 없다

---

## 문제

실무에선, `어떤 알고리즘을 어떤 언어로 구현해 이 문제를 해결해라`가 아닌, `이런 문제가 있는데 빨리 해결해라`와 같은 식으로 문제가 주어지므로, 다양한 해결책 사이의 장단점을 이해하고 어떤 상황에서 어떤 해결책을 적용해야 할지 잘 알고 있는 지원자를 선호할 것이 분명함

면접관은 일반적인 답보다는 구체적이고 자세한 답을 선호함
- 기본적인 정의 및 개요, 왜 사용하는지, 장단점 등

  ```
  ex. AJAX란 무엇인가? 
  Asynchronous JavaScript and XML의 약자이고,
  인터랙티브한 웹 애플리케이션을 만들기 위한 아키텍처 스타일입니다.
  인터페이스를 갱신하거나 입력을 확인하는 등 간단한 작업은 JavaScript를 통해 클라이언트에서 처리하고,
  서버와의 데이터 통신은 HTTP를 통해 백그라운드에서 처리합니다.
  클라이언트에서 처리할 데이터를 반환하기 위해 과거에는 XML 형식을 많이 썼지만,
  요즘은 많은 애플리케이션에서 JSON 등 다른 형식을 많이 사용합니다.
  AJAX를 써서 만든 애플리케이션은 일반적인 웹 애플리케이션처럼 UI가 지연되는 문제가 발생하지 않기 때문에 반응성이 좋습니다
  ```

---

### C++과 Java

`pass`

### C++의 `friend` 클래스

`pass`

### C++ 클래스의 인자 전달

`pass`

### C99/C++의 매크로와 인라인 함수 비교

`pass`

### 상속

> C -> B -> A <- D 와 같은 클래스 계층 있다고 가정.
> 클래스 B에 대한 레퍼런스를 인자로 받아들이는 메서드가 있다고 할 때, 어떤 클래스의 객체를 그 메서드에 인자로 전달할 수 있을까?

- B, C를 메서드에 전달할 수 있다
- D는 전혀 다른 특성 가지므로 전달 불가
- 자식 클래스에서는 부모 클래스의 모든 메서드를 구현해야 하지만, 
- 반대로 부모 클래스는 자식 클래스의 메서드가 모두 들어있지는 않으므로

### 가비지 컬렉션

> 가비지 컬렉션이란 무엇인가?
> 가비지 컬렉션을 구현하는 여러 방법에 대해 설명하고 각각의 장단점에 대해 논하라

- 가비지 컬렉션이란 프로그램에서 더 이상 쓰이지 않는 메모리를 자동으로 찾아서 가져가는 것을 뜻함
- 가비지 컬렉션 기능을 갖춘 대표적인 언어로 C#, Java, LISP, Python 등
- 장점
  - 허상 포인터 dangling pointer, 다중 할당해제 deallocation, 메모리 누수에 의한 버그를 없앨 수 있음
  - 메모리가 확실히 제대로 비워지도록 하기 위한 복잡한 메커니즘이 없어도 되기 때문에, 프로그램과 인터페이스 디자인이 훨씬 간단해짐
  - 메모리 할당 해제에 대한 신경을 덜 써도 되기 때문에, 개발 속도가 빨라짐
- 단점
  - 시스템에서 더 이상 필요하지 않은 메모리를 언제 되찾아올지 결정하기 위한 오버헤드 때문에 대체로 더 느림
  - 시스템에서 메모리를 너무 많이 할당하고 최선의 시점에서 메모리를 비우지 못하는 일도 발생할 수 있음
- 방법
  - 레퍼런스 카운팅
    - 한 객체를 참조하는 변수의 수 추적
    - 변수 레퍼런싱이 복사될 때마다 레퍼런스 카운트 늘어남
    - 객체 참조하고 있던 변수의 값이 바뀌거나 그 변수 영역을 벗어나면 그 객체의 레퍼런스 카운트가 줄어듦
    - 레퍼런스 카운트가 0이 되면 그 객체와 연관된 메모리가 비워짐
    - 장점: 간단하고 비교적 빠름
    - 단점: 
      - 단순하게 구현한 경우 원형 레퍼런스를 제대로 처리하지 못하는 문제; 외부에서 아무것도 그 리스트를 참조하지 않는 원형 연결 리스트는 모든 원소의 레퍼런스 카운트가 0이지만, 외부에서는 아무도 참조하지 않는 문제
      - 이때 약한 레퍼런스weak reference 객체의 레퍼런스 카운트에 포함되지 않는 레퍼런스를 이용해 처리 가능, 어떤 자료구조 내 모든 레퍼런스 사이클에 약한 레퍼런스가 있다면, 마지막 외부 레퍼런스가 없어진 뒤 그 구조를 없애버림
  - 추적형 가비지 컬렉터tracing garbage collector
    - 가비지 컬렉션 사이클 도중 더 이상 참조되지 않는 메모리를 찾아내, 할당해제하기 전까지는 그대로 둠
    - 표시 후 삭제mark-and-sweep 방식: 첫 단계에선 메모리 관리자가 프로그램의 각 스레드에서 액세스 할 수 있는 모든 객체 표시, 두번째 단계에서 다시 한 번 돌면서 표시되지 않은 객체 전부 비움
    - 단점: 가비지 컬렉션 하는 중에는 모든 실행 스레드가 잠시 중단되어야 함, 예측할 수 없는 타이밍에 실행이 멈추기도 함
      - JVM, .NET 공통언어 런타임 등 최신 추적형 가비지 컬렉터에서는 삼색 표시tri-color marking 방식 사용하여, 중간에 실행 멈추지 않아도 됨, 가비지 컬렉션 사이클에 필요한 오버헤드가 아예 없어지는 건 아님

### 32bit vs. 64bit 애플리케이션

개요

- 애플리케이션에서 쓸 수 있는 메모리 주소와 일반 레지스터의 크기를 나타내는 것
- 64bit 애플리케이션을 구동시키려면 64bit 프로세서와 OS 필요, 대부분의 64bit 시스템에서는 호환 모드로 32bit 애플리케이션 실행 가능

차이점

- 메모리 주소 크기: 이론적으로 64bit 메모리 주소를 이용하면 2^64 == 16 엑사바이트 메모리 주소 처리 가능, 32bit 프로세스는 4Gb 메모리 사용 가능
- 64bit의 장점
  - 요즘 컴퓨터는 물리적 메모리가 4Gb 넘기 때문에, 더 많은 데이터를 메모리에 올려놓고 느린 디스크 접근을 줄일 수 있는 64bit 애플리케이션이 더 빠를 수 있음
  - 확장된 주소 크기 덕분에 메모리 맵 파일 실용성도 좋아지고, 전통적인 API에 비해 파일 액세스 효율도 좋아짐
  - 레지스터 크기가 더 커지기 때문에 64bit 연산 자체도 빠를 수 있음
- 64bit의 단점
  - 모든 포인터 저장 시 메모리가 2배 필요
  - 프로세스 캐시 크기는 32bit 애플리케이션과 동일하기 때문에, 캐시에 조금밖에 넣지 못함; 캐시 미스 발생 확률 높아짐
- 코드에 따라 64bit가 더 빠르기도 하고, 32bit가 더 빠르기도 함

### 네트워크 성능

가장 중요한 두 가지는 지연 시간latency과 대역폭bandwidth

- 지연 시간 짧을수록, 대역폭 클수록 좋음
- 애플리케이션에 따라 지연 시간이 더 중요하거나 대역폭이 더 중요
- 지연 시간 latency
  - 특정 정보가 네트워크를 통해 전달되는 데 걸리는 시간
  - 물이 흐르는 파이프의 길이
  - VoIP 등에서 중요
- 대역폭 bandwidth
  - 통신이 연결된 상태에서 네트워크를 통해 데이터가 움직이는 속도
  - 물이 흐르는 파이프의 단면적
  - HD 동영상 스트리밍 등에서 중요

### 웹 애플리케이션 보안

> 웹 앱의 로그인 루틴에서 다음과 같은 코드의 보안 문제는 어떤 것이 있을까? 어떤 기술을 사용해 해결할 수 있을까?
> `Result = sql.executeQuery("SELECT uid FROM Users WHERE user='" + username + "' AND pass='" + pword + "';");`

문제

- 사용자가 제공한 문자열은 신뢰할 수 없는 출처로부터 오는 것이기 때문에, SQL Injection 공격을 받을 수 있다
  - 사용자가 `admin' OR 'A'='A`,라고 입력하고 패스워드로 아무거나 넣는 경우 쿼리는 `SELECT uid FROM Users WHERE user='admin' OR 'A'='A' AND pass='xyz';`가 됨
  - 비밀번호가 맞든 안 맞든 관리자 계정에 대한 uid가 리턴되는 문제
- 사용자가 제공한 데이터를 쿼리에 직접 이어붙이는 것은 사용자에게 애플리케이션 소스 코드를 일부 수정할 수 있는 능력을 부여한다는 것이기 때문에, 보안에 매우 취약해짐

해결 방법

- 데이터 필터링; 블랙리스팅 blacklisting
  - 사용자 문자열에서 문제를 일으킬 만한 패턴을 검색해 이스케이프 처리하거나 지움
  - 예를 들어 `'`를 전부 지움, 미리 알고 있는 공격 형식만 막을 수 있다는 단점
- prepared statement 활용
  - 데이터가 그 자리에 들어가기 전 미리 컴파일 됨, 사용자 데이터에 실행 가능한 SQL 문자열이 들어있다고 하더라도 쿼리 구조나 목적 자체가 달라질 수 없음
  - 여러번 실행시키더라도 쿼리 파싱-컴파일-최적화를 한번만 하면 되기 때문에 속도도 개선 가능
- 암호 해시 cryptographic hash
  - 평문cleantext으로 된 비밀번호 암호화
  - 임의의 입력 문자열 받아서 길이가 정해진 지문fingerprint 문자열 또는 다이제스트digest 문자열로 만들어주는 함수
  - 암호화된 문자열 복호화하거나 동일한 다이제스트 문자열이 생성되는 다른 문자열 계산하는 것이 `사실상` 불가능
    - 컴퓨터 성능 향상, 새로운 공격법 개발에 따라 가능해질 수 있다는 것
  - 해싱 함수 종류
    - MD5; 최근에는 문제가 있어서 안 쓰임
    - SHA-1; 보안상 완벽하지 않음
    - SHA-256; 전에는 안전하다고 여겨졌으나 금방 계산할 수 있어 더 이상 추천되지 않음
    - PBKDF2
    - bcrypt 등
- 소금 암호 해시 salt cryptographic hash
  - 암호 해시하는 경우 공격자가 Users 테이블 내용을 알더라도 비밀번호 자체를 모르기 때문에 바로 로그인 불가, 다만 brute-force 공격으로 찾을 수는 있음; 무지개 표 rainbow table- 널리 쓰이는 비밀번호 가지고 다이제스트를 미리 계산해서 저장한 테이블, GPU 기반 암호 해독기로 해시 바로 계산
  - salt; 해시하기 전 비밀번호에 덧붙이는 임의의 문자열, 평문으로 저장되어 공격자가 바로 알아낼 수 있지만, 사용자마다 다름
  - 공격자 입장에서 모든 비밀번호를 한꺼번에 깰 수 없고 개별 사용자 비밀번호를 따로 깨야 함
- 해시 반복
  - 한 해시 함수 적용 결과를 다른 해시 함수에 집어넣어 얻은 결과 이용
  - PBKDF2, bcrypt 등 알고리즘에는 반복 과정 내장되고, 반복 회수는 사용자가 매개변수로 지정할 수 있음
  - 적당히 반복하면 속도에 거의 영향 없고, 공격자가 해독하는데 걸리는 시간은 훨씬 오래 걸림

### 암호

> 대칭키 암호와 공개키 암호 사이의 차이점과, 각 방법을 사용할 수 있는 상황의 예?

대칭키 암호 symmetric key cryptography

- 공유키 암호 shared key cryptography
- 두 사람이 암호화-복호화에 동일 키 사용하는 방법
- 장점
  - 공개키 암호에 비해 훨씬 빠름
  - 구현 난이도 쉬운 편
  - 특허 문제 낮음
  - 프로세싱 파워 약해도 처리 쉬움
- 단점
  - 메시지 주고 받는 당사자가 같은 키를 갖고 있어야 하므로 불편, 상황에 따라 불가능하기도
  - 한쪽이 다른 쪽에 키를 알려주려면 보안 유지되는 통신 필요한데, 순수한 대칭키 암호 시나리오에서는 보안 갖춰진 통신을 일반적으로 사용할 수 없음, 애초에 그런 통신이 있으면 암호화 할 필요도 없음

공개키 암호 public key cryptography

- 암호화할 때는 공개키 public key, 복호화할 때는 비밀키 private key 사용하는 방식
- 장점
  - 공개키가 공개되더라도 암호화된 메시지는 안전하게 유지됨; 보안이 갖춰지지 않은 채널 통해 전송해도 안전
  - 공유 세션 키를 구축해 대칭키 암호를 통해 통신하면, 공개키 암호의 편리함과 성능을 동시에 누릴 수 있음

공개키 암호를 써서 웹 브라우저와 웹 사이트 간 공유 세션 키를 구축하고, 개인 정보를 실제 획득할 때는 대칭키 암호를 써서 데이터를 주고 받는 방식이 주로 사용됨

### 해시 테이블과 이진 검색 트리

> 해시 테이블과 이진 검색 트리를 비교하고, 각각의 장단점?
> 메모리가 제한된 모바일 기기용 주소록에 사용할 자료구조를 설계한다면?

해시 테이블

- 데이터 저장, 읽기 속도가 일반적으로 O(1) 이므로 매우 빠름
- 그 외 용도로는 제약이 많음

이진 검색 트리

- 데이터 저장, 읽기 속도가 O(logn), 해시 테이블보다는 느리지만 그래도 빠른 편
- 자료가 정렬된 순서 그대로 유지됨

모바일 기기에서는 자료 저장에 쓰이는 메모리를 최대한 아껴야 함

- 해시 테이블처럼 정렬되지 않은 자료구조 사용시, 정렬하기 위해 메모리 추가 사용하게 됨
- 대부분의 경우에 주소록 데이터가 수천 개를 넘지 않기 때문에 O(logn) 속도면 충분하고, 메모리를 아끼는 것이 중요함

### 맵리듀스 MapReduce

> 맵리듀스가 어떻게 작동하는지, 어디에 쓰이는지?

(하둡 등) 분산 인프라를 이용해 대규모 데이터 집합을 병렬로 처리하기 위한 일반화된 기술

- 업무를 여러 머신으로 분배하는 것과 관련된 부분을 맵리듀스 프레임워크에서 챙겨주기 때문에
- 데이터 처리 및 분석 로직에만 초점을 맞출 수 있음

시스템 작동 과정

- 맵map 단계
  - 시스템에서 데이터 필터링, 정렬 통해 변환
  - 변환은 서로 다른 머신에서 병렬로 진행
  - 변환된 각 데이터 조각을 특정 키와 연관시킴
  - 변환된 데이터는 보통 임시 저장소인 디스크에 저장
- 셔플shuffle 단계
  - 키가 같은 모든 데이터 조각을 같은 머신에서 사용할 수 있도록 변환된 데이터를 여러 머신으로 이동시킴
- 리듀스reduce 단계
  - 키가 같은 조각을 전부 읽어서 어떤 분산 작업 수행하거나 데이터를 추가로 변환함
- 리듀스 단계에서 나온 결과를 전부 합치면 최종 결과물 완성됨

활용

- 데이터가 너무 커서 메모리에 다 넣을 수 없지만, 처리할 수 있는 수준으로 쪼개 작업할 수 있는 경우
- 임시 데이터 저장 공간이 상당히 많이 필요하고, 서로 다른 머신 사이에서 작업을 조율하고 데이터를 옮기기 위해 적지 않은 시간이 걸리지만, 아주 큰 데이터 집합을 빠르게 처리 가능
